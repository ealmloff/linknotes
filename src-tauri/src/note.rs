/*!
## Name of Code Artifact:
Contextual Document Management for Tauri Workspaces

## Brief Description of What the Code Does:
This code manages contextual documents within a Tauri-based workspace. It includes functionality for saving, retrieving, updating, tagging, and deleting documents. The code also incorporates classification logic for tagging documents using embeddings generated by BERT.

## Programmerâ€™s Name: Evan Almloff, Suhaan Syed

## Date the Code Was Created: 10/14/2024

## Dates the Code Was Revised:
December 10, 2024: Fixed document retrieval bug in get_tags. (Author: Evan)
December 12, 2024: Enhanced exception handling in save_note. (Author: Evan)

## Preconditions:

- A Tauri application environment must be set up.
- Workspace ID must be valid and accessible.
- Database (surrealdb) must be configured and running.

### Acceptable and Unacceptable Input Values or Types:

- Title (String): Non-empty, unique title for each document.
- Tags (Vec<Tag>): Each tag must have a valid name and manual flag which should be true if it was created by the user.
- Text (String): Any non-empty string.
- Workspace ID (WorkspaceId): A workspace that was created by [`crate::workspace::load_workspace`].

### Unacceptable Inputs:

- Empty strings for title or text.
- Invalid or non-existent workspace IDs.
- Invalid tags in search methods

## Postconditions:

Document is saved, updated, or removed as per the invoked function.
Tags are added or retrieved with deduplication.
Classifier-based tagging is applied automatically.

## Return Values or Types, and Their Meanings:

Ok(()): Operation succeeded without errors.
Err(DocumentDoesNotExistError): Document with the specified title was not found.
Result<Vec<Tag>, DocumentDoesNotExistError>: Returns a list of tags or indicates the document does not exist.

### Error and Exception Condition Values or Types That Can Occur, and Their Meanings:

DocumentDoesNotExistError: Document lookup failed.
String: Returned for general errors like database issues or classifier failures.
I/O errors (std::io::Error): Issues with file operations.

## Side Effects:

Modifies the workspace database.
Writes/reads files to/from the workspace directory.
Updates classifier with document embeddings.

## Invariants:

Tags are always sorted and deduplicated before storage.
Document paths are canonicalized to ensure consistency.
Automatic tags are always appended to existing manual tags.

## Any Known Faults:

Limited error recovery mechanisms for file I/O operations.
Potential bottlenecks during embedding generation with BERT.
*/

use kalosm::language::*;
use serde::{Deserialize, Serialize};
use std::fs;
use std::ops::Range;
use std::path::PathBuf;
use surrealdb::sql::Id;

#[cfg(test)]
use pretty_assertions::assert_eq; // Import the `assert_eq` macro for comparing values.

use crate::bert; // Import the `bert` function from the root module.
use crate::classifier::chunk_text; // Import the `chunk_text` function from the `classifier` module.
use crate::workspace::{get_workspace_ref, WorkspaceId}; // Import the `get_workspace_ref` and `WorkspaceId` types from the `workspace` module.

#[derive(Serialize, Deserialize)] // Implement the `Serialize` and `Deserialize` traits for the `ContextualDocumentLocation` struct.
struct ContextualDocumentLocation {
    // Define the `ContextualDocumentLocation` struct.
    document_id: Id,        // An `Id` field to store the document ID.
    pub location: PathBuf,  // A `PathBuf` field to store the document location.
    segments: Vec<Segment>, // A `Vec<Segment>` field to store the document segments.
}

/// A struct representing a document with its associated tags.
///
/// # Fields
///
/// * `document` - The main document content.
/// * `tags` - A list of tags associated with the document.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct ContextualDocument {
    pub document: Document,
    pub tags: Vec<Tag>,
}

impl AsRef<Document> for ContextualDocument {
    fn as_ref(&self) -> &Document {
        // Implement the `as_ref` method for the `ContextualDocument` struct.
        &self.document // Return a reference to the document.
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, Ord)]
pub struct Tag {
    // Define the `Tag` struct.
    pub name: String, // A `String` field to store the tag name.
    pub manual: bool, // A `bool` field to indicate if the tag was created by the user or automatically added.
}

impl PartialEq for Tag {
    fn eq(&self, other: &Self) -> bool {
        // Implement the `eq` method for the `Tag` struct.
        self.name == other.name && self.manual == other.manual // Compare the tag name and manual flag for equality.
    }
}

impl PartialOrd for Tag {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        // Implement the `partial_cmp` method for the `Tag` struct.
        self.name.partial_cmp(&other.name) // Compare the tag names for ordering.
    }
}

const DOCUMENT_NAME_TABLE: &str = "document_paths";

#[derive(Serialize, Deserialize, PartialEq)] // Implement the `Serialize` and `Deserialize` traits for the `Segment` struct. These traits let us save and load the struct to and from a database.
struct Segment {
    source_char_range: Range<usize>, // A `Range<usize>` field to store the character range of the segment.
}

/// DocumentDoesNotExistError is an error type that indicates that a document does not exist.
#[derive(thiserror::Error, Debug, Serialize, Deserialize)]
#[error("document does not exist")]
pub struct DocumentDoesNotExistError;

// Set the tags for a note with the given a title in the workspace
#[tauri::command]
pub async fn set_tags(
    title: String,             // Define the `title` parameter as a `String`.
    mut tags: Vec<Tag>,        // Define the `tags` parameter as a mutable `Vec<Tag>`.
    workspace_id: WorkspaceId, // Define the `workspace_id` parameter as a `WorkspaceId`.
) -> Result<(), DocumentDoesNotExistError> {
    tracing::info!("set_tags called with title {:?} and tags {:?}", title, tags);
    let workspace = get_workspace_ref(workspace_id); // Get a reference to the workspace using the `workspace_id`.
    workspace.retrain_classifier(); // Retrain the classifier for the workspace.
    let document_table = workspace.document_table().await.unwrap(); // Get the document table for the workspace.
    let db = document_table.table().db(); // Get the database connection for the document table.
    let table_name = document_table.table().table(); // Get the table name for the document table.
    let location: ContextualDocumentLocation = db // Retrieve the document location based on the title.
        .select((DOCUMENT_NAME_TABLE, title))
        .await
        .unwrap() // Unwrap the result.
        .ok_or(DocumentDoesNotExistError)?;
    let note: ContextualDocument = document_table
        .select(location.document_id.clone()) // Select the document based on the document ID.
        .await
        .unwrap();
    let automatic_tags = note.tags.into_iter().filter(|tag| !tag.manual); // Filter out the automatic tags.
    tags.extend(automatic_tags);
    tags.sort(); // Sort the tags.
    tags.dedup(); // Deduplicate the tags.
    let id = location.document_id;
    db.query(format!(
        "UPDATE {}:{} SET tags = {}",
        table_name,
        id,
        serde_json::to_string(&tags).unwrap()
    ))
    .await
    .unwrap();

    Ok(())
}

/// Retrieves the location of a document from the database based on the provided title.
///
/// This function performs an asynchronous database query to select the document location
/// from the `DOCUMENT_NAME_TABLE` using the given `title`. If the document is found, its
/// location is returned. If the document does not exist, a `DocumentDoesNotExistError` is returned.
///
/// # Errors
///
/// Returns a `DocumentDoesNotExistError` if the document with the specified title does not exist in the database.
#[tauri::command]
pub async fn get_tags(
    // Define the `get_tags` function as a Tauri command.
    title: String,
    workspace_id: WorkspaceId,
) -> Result<Vec<Tag>, DocumentDoesNotExistError> {
    tracing::info!("get_tags called with title {:?}", title);
    let workspace = get_workspace_ref(workspace_id);
    let document_table = workspace.document_table().await.unwrap();
    let db = document_table.table().db();

    let location: ContextualDocumentLocation = db
        .select((DOCUMENT_NAME_TABLE, &title))
        .await
        .unwrap()
        .ok_or(DocumentDoesNotExistError)?;
    let note: ContextualDocument = document_table.select(location.document_id).await.unwrap();
    Ok(note.tags)
}

/// Save a note with a title, and contents in a workspace. While saving the note, we generate embeddings for the document using BERT.
/// The embeddings are used to add one tag automatically based on the classifier. They will also be used for search later.
///
/// # Arguments
///
/// * `title` - The title of the note.
/// * `text` - The text of the note.
/// * `workspace_id` - The ID of the workspace to save the note in.
///
/// # Preconditions
///
/// - The workspace must exist.
///
/// # Returns
///
/// A `Result` containing `()` (the empty type) if the note is saved successfully, or an error message as a `String` if the note cannot be saved.
///
/// # Errors
///
/// This function will return an error if:
/// - The workspace does not exist
/// - the query execution fails
/// - if there is an issue serializing or deserializing the database query and result
/// - if there is an issue downloading the bert model
/// - if there is an issue training the classifier
#[tauri::command]
pub async fn save_note(
    title: String,
    text: String,
    workspace_id: WorkspaceId,
) -> Result<(), String> {
    tracing::info!("Add_note called");
    tracing::info!("Workspace added with id: {:?}", workspace_id);

    let workspace = get_workspace_ref(workspace_id);
    let document_path = workspace.document_path(&title).unwrap();

    // Write the note content to the file
    fs::write(&document_path, &text).unwrap();

    let document_table = workspace.document_table().await.unwrap();
    let db = document_table.table().db();
    let document = Document::from_parts(title.clone(), text);
    tracing::info!("Chunking document");
    let body = document.body();
    let sentences = chunk_text(body);
    let bert = bert().await.unwrap();
    let embeddings = bert
        .embed_batch(sentences.iter().map(|sentence| &body[sentence.clone()]))
        .await
        .unwrap();

    let chunks = sentences
        .clone()
        .into_iter()
        .zip(embeddings.into_iter())
        .map(|(byte_range, embedding)| Chunk {
            byte_range,
            embeddings: vec![embedding],
        });
    let segments = sentences
        .iter()
        .map(|byte_range| Segment {
            source_char_range: byte_range.clone(),
        })
        .collect();
    tracing::info!("Looking for existing document");
    // First check if the document already exists
    let current_location: Option<ContextualDocumentLocation> = db
        .select((DOCUMENT_NAME_TABLE, title.as_str()))
        .await
        .unwrap();
    let mut tags = Vec::new();
    if let Some(current_location) = &current_location {
        let previous_document = document_table
            .select(current_location.document_id.clone())
            .await
            .unwrap();
        // If this is the same as the note already in the db, just return
        if current_location.segments == segments && previous_document.document == document {
            return Ok(());
        }
        tags = previous_document.tags.clone();
        // Delete the old document if it exists
        document_table
            .delete(current_location.document_id.clone())
            .await
            .unwrap();
    }

    tags.retain(|tag| tag.manual);
    // Classify the document and add an automatic tag
    let mut contextual = ContextualDocument { document, tags };
    let tag = workspace // Classify the document using the workspace classifier.
        .classify(&contextual) // Classify the document using the workspace classifier.
        .await // Await the result.
        .map_err(|err| err.to_string())?; // Map any errors to a string.
    contextual.tags.push(tag); // Push the tag to the document tags.

    tracing::info!("Inserting document with id: {:?}", contextual);
    let document_id = document_table // Insert the document into the document table.
        .insert_with_chunks(contextual, chunks) // Insert the document with the associated chunks.
        .await
        .map_err(|err| err.to_string())?;
    tracing::info!("Document inserted successfully");

    let location = ContextualDocumentLocation {
        document_id,
        location: document_path,
        segments,
    };

    // If it doesn't, create it
    if current_location.is_none() {
        // If the document does not exist, create it.
        let _: Option<ContextualDocumentLocation> = db // Create a new document location entry in the database.
            .create((DOCUMENT_NAME_TABLE, title.as_str())) // Create a new document location entry in the database.
            .content(location)
            .await // Await the result.
            .map_err(|err| err.to_string())?; // Map any errors to a string.
    }
    // Otherwise, update it
    else {
        let _: Option<ContextualDocumentLocation> = db // Update the document location entry in the database.
            .update((DOCUMENT_NAME_TABLE, title.as_str())) // Update the document location entry in the database.
            .content(location)
            .await
            .map_err(|err| err.to_string())?; // Map any errors to a string.
    }

    Ok(())
}

/// Remove a note from a specific path from a workspace.
///
/// # Arguments
///
/// * `title` - The title of the note to remove.
/// * `workspace_id` - The ID of the workspace to remove the note from.
///
/// # Preconditions
///
/// - The workspace must exist.
/// - The note must exist in the workspace.
///
/// # Returns
///
/// Nothing.
#[tauri::command]
pub async fn remove_note(title: String, workspace_id: WorkspaceId) {
    tracing::info!("Removing note with title: {:?}", title); // Log the removal of a note with the specified title.
    let workspace = get_workspace_ref(workspace_id); // Get a reference to the workspace using the `workspace_id`.
    let document_table = workspace.document_table().await.unwrap(); // Get the document table for the workspace.
    let db = document_table.table().db(); // Get the database connection for the document table.

    // Get the document path
    let document_path = workspace.document_path(&title).unwrap(); // Get the document path based on the title.

    // First check if the document already exists
    let current_location: Option<ContextualDocumentLocation> =
        db.delete((DOCUMENT_NAME_TABLE, &title)).await.unwrap();
    if let Some(current_location) = &current_location {
        // Delete the old document if it exists
        document_table
            .delete(current_location.document_id.clone())
            .await
            .unwrap();
    }

    // Remove the .txt file
    if document_path.exists() {
        fs::remove_file(document_path).unwrap();
    }
}

/// Read a note from a specific path from a workspace.
///
/// # Arguments
///
/// * `title` - The title of the note to read.
/// * `workspace_id` - The ID of the workspace to read the note from.
///
/// # Preconditions
///
/// - The workspace must exist.
/// - The note must exist in the workspace.
///
/// # Returns
///
/// A `Result` containing a `ContextualDocument` if the note is read successfully, or an error message as a `DocumentDoesNotExistError` if the note cannot be read.
///
/// # Errors
///
/// This function will return an error if:
/// - The document does not exist in the workspace
#[tauri::command]
pub async fn read_note(
    // Define the `read_note` function as a Tauri command.
    title: String,             // Define the `title` parameter as a `String`.
    workspace_id: WorkspaceId, // Define the `workspace_id` parameter as a `WorkspaceId`.
) -> Result<ContextualDocument, DocumentDoesNotExistError> {
    // Define the return type of the function.
    let workspace = get_workspace_ref(workspace_id);
    let document_table = workspace.document_table().await.unwrap();
    let db = document_table.table().db(); // Get the database connection for the document table.
    let location: ContextualDocumentLocation = db // Retrieve the document location based on the title.
        .select((DOCUMENT_NAME_TABLE, &title)) // Select the document location based on the title.
        .await
        .unwrap() // Unwrap the result.
        .ok_or(DocumentDoesNotExistError)?;
    let note: ContextualDocument = document_table.select(location.document_id).await.unwrap();
    Ok(note)
}

// Tests for the note module.
#[tokio::test]
async fn test_set_tags() {
    use crate::note::save_note;
    use crate::workspace::{
        delete_workspace, files_in_workspace, load_workspace, unload_workspace,
    };
    use std::env::temp_dir;

    _ = tracing_subscriber::fmt::try_init();

    let temp = temp_dir();
    let workspace = load_workspace(temp);
    let title = "test-note".to_string();
    let text = "test note".to_string();
    save_note(title.clone(), text.clone(), workspace)
        .await
        .unwrap();
    let tags = vec![
        Tag {
            name: "tag1".to_string(),
            manual: true,
        },
        Tag {
            name: "tag2".to_string(),
            manual: true,
        },
    ];
    set_tags(title.clone(), tags.clone(), workspace)
        .await
        .unwrap();

    let title2 = "my-other-test-note".to_string();
    let text2 = "testing other note".to_string();
    save_note(title2.clone(), text2.clone(), workspace)
        .await
        .unwrap();
    let tags2 = vec![
        Tag {
            name: "tag2".to_string(),
            manual: true,
        },
        Tag {
            name: "tag3".to_string(),
            manual: true,
        },
    ];
    set_tags(title2.clone(), tags2.clone(), workspace)
        .await
        .unwrap();

    let notes = files_in_workspace(workspace).await;

    assert_eq!(
        notes,
        vec![
            ContextualDocument {
                document: Document::from_parts(title, text.clone()),
                tags
            },
            ContextualDocument {
                document: Document::from_parts(title2, text2.clone()),
                tags: tags2
            }
        ]
    );

    let results =
        crate::search::search("test".to_string(), vec!["tag2".to_string()], 10, workspace)
            .await
            .unwrap();
    assert_eq!(results.len(), 2);
    assert_eq!(results[0].title, "test-note");
    assert_eq!(results[0].character_range, 0..text.len());
    assert_eq!(results[1].title, "my-other-test-note");
    assert_eq!(results[1].character_range, 0..text2.len());

    let results = crate::search::search(
        "test".to_string(),
        vec!["tag1".to_string(), "tag2".to_string()],
        10,
        workspace,
    )
    .await
    .unwrap();
    assert_eq!(results.len(), 1);
    assert_eq!(results[0].title, "test-note");
    assert_eq!(results[0].character_range, 0..text.len());

    let results = crate::search::search(
        "my note is here".to_string(),
        vec!["testing".to_string()],
        10,
        workspace,
    )
    .await
    .unwrap();
    assert!(results.is_empty());

    delete_workspace(workspace);
    unload_workspace(workspace);
}
